# Data Model: Firebase Authentication & Authorization System

**Feature**: 002-auth-system
**Created**: 2025-12-26
**Status**: Design Phase

## Overview

This document defines the data model for the Firebase Authentication & Authorization system. The system uses Firebase Authentication for identity management and custom claims for authorization. **No new Firestore collections are required** - the system relies entirely on Firebase Auth's built-in user management and custom claims.

## Entities

### 1. Firebase Auth User (Managed by Firebase)

Firebase Authentication manages user identity. This entity is NOT stored in Firestore but is managed by Firebase Auth service.

**Type**: Firebase Auth User Object

**Fields**:

| Field | Type | Description | Required | Default |
|-------|------|-------------|----------|---------|
| `uid` | `string` | Unique user identifier | Yes | Auto-generated by Firebase |
| `email` | `string \| null` | User email (for OAuth users) | No | `null` for anonymous |
| `displayName` | `string \| null` | User display name | No | `null` |
| `photoURL` | `string \| null` | User profile photo URL | No | `null` |
| `isAnonymous` | `boolean` | Whether user is anonymous | Yes | `true` for anonymous, `false` for OAuth |
| `providerId` | `string` | Auth provider ID | Yes | `"anonymous"` or `"google.com"` |
| `metadata` | `UserMetadata` | Creation and last sign-in timestamps | Yes | Auto-managed by Firebase |

**Relationships**: None (identity only)

**Validation Rules**:
- `uid` is immutable after creation
- `isAnonymous` users cannot have email
- `providerId` must be valid Firebase provider
- Anonymous users cannot be granted admin claims (enforced in admin grant script)

**State Transitions**:
```
Unauthenticated → Anonymous (automatic on /guest/[projectId])
Unauthenticated → Authenticated (Google OAuth on /login)
Anonymous → Authenticated (account linking - out of scope for this feature)
```

**Indexes**: Managed by Firebase Auth (indexed by uid, email)

---

### 2. Custom Claims (Managed by Firebase)

Custom claims are stored in the Firebase ID token and are NOT persisted in Firestore. They are set server-side using Firebase Admin SDK.

**Type**: Firebase ID Token Custom Claims

**Fields**:

| Field | Type | Description | Required | Default |
|-------|------|-------------|----------|---------|
| `admin` | `boolean` | Whether user has admin privileges | No | `undefined` (non-admin) |

**Relationships**: Embedded in ID token for specific `uid`

**Validation Rules**:
- `admin` can only be `true` or `undefined` (no explicit `false` values)
- Cannot be set on anonymous users (`isAnonymous === true`)
- Can only be set server-side via Firebase Admin SDK
- Maximum payload size: 1000 bytes (per Firebase limits)
- Claims are propagated via ID token (re-authentication required for immediate effect)

**State Transitions**:
```
No claim (undefined) → admin: true (via admin grant script)
admin: true → No claim (via admin revoke - future feature)
```

**Security Constraints**:
- MUST be set only via server-side script or Cloud Function
- MUST NOT be settable from client code
- MUST be validated in Firestore/Storage security rules for admin operations

---

### 3. Auth State (Client-Side Only)

Client-side auth state is managed by Firebase Auth SDK and stored in browser storage (IndexedDB/localStorage). This is NOT server-managed.

**Type**: Client-Side State (Not Persisted to Firebase)

**Fields**:

| Field | Type | Description | Required | Default |
|-------|------|-------------|----------|---------|
| `user` | `User \| null` | Current Firebase Auth user | Yes | `null` |
| `isAdmin` | `boolean` | Whether current user has admin claim | Yes | `false` |
| `isLoading` | `boolean` | Whether auth state is being initialized | Yes | `true` |
| `isAnonymous` | `boolean` | Whether current user is anonymous | Yes | `false` |

**Relationships**: Derived from Firebase Auth User and ID Token

**Validation Rules**:
- `isLoading` must be `true` until Firebase auth initializes
- `isAdmin` is derived from `idTokenResult.claims.admin === true`
- `isAnonymous` is derived from `user.isAnonymous`
- Route guards MUST NOT execute while `isLoading === true`

**State Transitions**:
```
Loading → Unauthenticated (no user found)
Loading → Anonymous (anonymous user found or created)
Loading → Authenticated Non-Admin (OAuth user without admin claim)
Loading → Authenticated Admin (OAuth user with admin: true claim)
```

---

## Data Flow

### 1. Guest User Authentication Flow

```
User visits /guest/[projectId]
  ↓
Check auth state (client)
  ↓
If unauthenticated → signInAnonymously()
  ↓
Firebase creates anonymous user (uid auto-generated)
  ↓
ID token issued (no custom claims)
  ↓
User can access guest experience
```

**Data Changed**: Firebase Auth User created (isAnonymous: true)

---

### 2. Admin Login Flow

```
User visits /login
  ↓
Click "Sign in with Google"
  ↓
signInWithPopup(GoogleAuthProvider)
  ↓
Firebase creates/retrieves user (uid, email, displayName)
  ↓
ID token issued (may or may not have admin: true claim)
  ↓
Client checks idTokenResult.claims.admin
  ↓
If admin: true → Redirect to /admin
If undefined → Show waiting message
```

**Data Changed**: Firebase Auth User created/updated (OAuth)

---

### 3. Admin Grant Flow

```
Super-admin runs: node scripts/grant-admin.ts user@example.com
  ↓
Script validates email exists in Firebase Auth
  ↓
admin.auth().setCustomUserClaims(uid, { admin: true })
  ↓
Custom claims updated in Firebase Auth (server-side)
  ↓
User must re-authenticate to receive new token
  ↓
New ID token includes admin: true claim
  ↓
User can now access /admin and /workspace routes
```

**Data Changed**: Custom claims set on Firebase Auth User

---

### 4. Route Guard Validation Flow

```
User navigates to /admin
  ↓
TanStack Router beforeLoad executes
  ↓
Check auth.isLoading
  ↓
If loading → Wait for auth to resolve
  ↓
Check auth.user
  ↓
If null → Redirect to /login
  ↓
Check auth.isAnonymous
  ↓
If true → Redirect to /login
  ↓
Check auth.isAdmin
  ↓
If false → Redirect to /login
  ↓
If true → Allow access
```

**Data Changed**: None (read-only check)

---

## Security Rules

### Firestore Security Rules

```javascript
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function: Check if user is admin
    function isAdmin() {
      return request.auth != null
        && request.auth.token.admin == true;
    }

    // Helper function: Check if user is authenticated (not anonymous)
    function isAuthenticated() {
      return request.auth != null
        && request.auth.token.firebase.sign_in_provider != 'anonymous';
    }

    // Example: Admin-only collection
    match /workspaces/{workspaceId} {
      allow read, write: if isAdmin();
    }

    // Example: Guest-accessible collection (read-only)
    match /events/{eventId} {
      allow read: if request.auth != null; // Anonymous users can read
      allow write: if isAdmin(); // Only admins can write
    }

    // Example: User-specific data (authenticated users only)
    match /users/{userId} {
      allow read, write: if isAuthenticated()
        && request.auth.uid == userId;
    }
  }
}
```

### Storage Security Rules

```javascript
rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {

    // Helper function: Check if user is admin
    function isAdmin() {
      return request.auth != null
        && request.auth.token.admin == true;
    }

    // Example: Admin-only uploads
    match /admin-uploads/{allPaths=**} {
      allow read, write: if isAdmin();
    }

    // Example: Guest uploads (anonymous users can write)
    match /guest-uploads/{eventId}/{fileName} {
      allow read: if request.auth != null;
      allow write: if request.auth != null; // Anonymous users can upload
    }
  }
}
```

---

## TypeScript Types

### Auth Types

Location: `src/domains/auth/types/auth.types.ts`

```typescript
import type { User, IdTokenResult } from 'firebase/auth'

/**
 * Custom claims structure in ID token
 */
export interface CustomClaims {
  admin?: boolean
}

/**
 * Extended ID token result with typed custom claims
 */
export interface TypedIdTokenResult extends IdTokenResult {
  claims: IdTokenResult['claims'] & CustomClaims
}

/**
 * Auth state managed by AuthProvider
 */
export interface AuthState {
  /** Current Firebase Auth user (null if unauthenticated) */
  user: User | null

  /** Whether user has admin: true custom claim */
  isAdmin: boolean

  /** Whether user is anonymous */
  isAnonymous: boolean

  /** Whether auth state is being initialized */
  isLoading: boolean

  /** ID token result with custom claims (null if unauthenticated) */
  idTokenResult: TypedIdTokenResult | null
}

/**
 * Router context including auth state
 */
export interface RouterContext {
  auth: AuthState
}
```

**Import paths:**
```typescript
// In application code
import type { AuthState, CustomClaims } from '@/domains/auth'

// In routes
import type { RouterContext } from '@/routes/__root'
```

### Admin Grant Script Types

```typescript
/**
 * Input validation schema for admin grant script
 */
export const GrantAdminSchema = z.object({
  email: z.string().email('Invalid email format'),
})

export type GrantAdminInput = z.infer<typeof GrantAdminSchema>

/**
 * Admin grant result
 */
export interface GrantAdminResult {
  success: boolean
  uid: string
  email: string
  message: string
}
```

---

## Performance Considerations

### 1. Token Refresh

- Firebase Auth tokens expire after 1 hour
- Firebase SDK automatically refreshes tokens in the background
- Force refresh after custom claims change: `getIdToken(true)`
- Route guards must wait for token refresh to complete

### 2. Anonymous User Cleanup

- Enable automatic cleanup in Firebase Console: Authentication → Settings → Automatic cleanup
- Anonymous users inactive for 30 days are automatically deleted
- No manual cleanup required
- Reduces storage costs and user quota consumption

### 3. Concurrent Anonymous Users

- Firebase supports ~1 million concurrent connections
- 10k concurrent anonymous users is well within limits
- Each anonymous user consumes minimal resources (no email, no profile data)
- No scalability concerns for target load

### 4. Custom Claims Propagation Delay

- Custom claims are embedded in ID tokens
- Tokens cached client-side for up to 1 hour
- User must re-authenticate or force token refresh for immediate effect
- Consider Firestore metadata doc pattern for real-time claims sync (see research.md)

---

## Testing Considerations

### 1. Unit Testing Auth Hooks

- Mock `firebase/auth` module with `vi.mock()`
- Test all auth state transitions (loading → unauthenticated → anonymous → admin)
- Verify `isAdmin` derived correctly from `idTokenResult.claims.admin`

### 2. Testing Route Guards

- Mock router context with different auth states
- Verify redirects for unauthenticated, anonymous, non-admin users
- Verify admin users can access protected routes

### 3. Testing Security Rules

- Use `@firebase/rules-unit-testing` with Firebase Emulator
- Test anonymous users can read but not write admin collections
- Test admin users can read and write admin collections
- Test custom claims validation (`request.auth.token.admin`)

**Note**: Firebase Console UI does not support custom claims testing - must use emulator.

---

## Migration Notes

This feature does NOT require any data migration:

- No new Firestore collections created
- No existing data modified
- Firebase Auth users are created on-demand
- Custom claims are opt-in (only set for admins)

**Backward Compatibility**: This feature is additive only. Existing unauthenticated users will be automatically signed in as anonymous on guest routes.

---

## References

- Firebase Auth User Management: https://firebase.google.com/docs/auth/admin/manage-users
- Custom Claims: https://firebase.google.com/docs/auth/admin/custom-claims
- Security Rules: https://firebase.google.com/docs/firestore/security/rules-conditions
- Token Refresh: https://firebase.google.com/docs/reference/js/auth.user#getidtoken
