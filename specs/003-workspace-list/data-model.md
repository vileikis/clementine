# Data Model: Admin Workspace Management

**Feature**: 003-workspace-list
**Date**: 2025-12-28
**Purpose**: Define data entities, schemas, validation rules, and state transitions for workspace management

---

## Overview

This feature introduces a single primary entity (**Workspace**) stored in Firestore. Workspaces are organizational units that admins can create, access via slug-based URLs, and soft-delete. The data model enforces slug uniqueness (case-insensitive), tracks lifecycle state (active/deleted), and maintains audit timestamps.

---

## Entities

### Workspace

**Description**: Represents an organizational unit or project space within Clementine. Each workspace has a unique slug for URL-based access and supports soft deletion for data retention.

**Firestore Collection**: `workspaces`

**Fields**:

| Field | Type | Required | Description | Constraints |
|-------|------|----------|-------------|-------------|
| `id` | string | Yes | Unique workspace identifier (Firestore document ID) | Auto-generated by Firestore |
| `name` | string | Yes | Human-readable workspace name | 1-100 characters |
| `slug` | string | Yes | URL-safe, unique identifier derived from name | 1-50 characters, lowercase, alphanumeric + hyphens, must match `/^[a-z0-9][a-z0-9-]*[a-z0-9]$\|^[a-z0-9]$/` |
| `status` | WorkspaceStatus | Yes | Current lifecycle state | Enum: "active" \| "deleted" |
| `deletedAt` | number \| null | Yes | Unix timestamp (ms) when workspace was soft deleted | `null` if active, timestamp if deleted |
| `createdAt` | number | Yes | Unix timestamp (ms) when workspace was created | Auto-set on creation |
| `updatedAt` | number | Yes | Unix timestamp (ms) of last modification | Auto-set on create/update |

**Validation Rules**:

1. **Slug Uniqueness**: No two workspaces (active or deleted) can have the same slug (case-insensitive)
2. **Status-DeletedAt Consistency**: If `status === "deleted"`, then `deletedAt` must NOT be `null`
3. **Status-DeletedAt Inverse**: If `status === "active"`, then `deletedAt` MUST be `null`
4. **Slug Format**: Must match pattern `/^[a-z0-9][a-z0-9-]*[a-z0-9]$|^[a-z0-9]$/` (lowercase letters, numbers, hyphens; no leading/trailing hyphens)
5. **Name Length**: Minimum 1 character, maximum 100 characters
6. **Slug Length**: Minimum 1 character, maximum 50 characters
7. **Timestamp Validity**: `createdAt`, `updatedAt`, and `deletedAt` (when set) must be positive integers

**State Transitions**:

```
┌─────────┐
│ (none)  │
└────┬────┘
     │ CREATE
     ▼
┌─────────┐
│ active  │
└────┬────┘
     │ SOFT DELETE
     ▼
┌─────────┐
│ deleted │ (terminal state - no restoration)
└─────────┘
```

**Relationships**: None (self-contained entity)

**Indexes**:

Required Firestore indexes for efficient queries:

1. **Slug + Status** (compound):
   - Fields: `slug` (ASC), `status` (ASC)
   - Purpose: Fast workspace resolution by slug (only active workspaces)

2. **Status + CreatedAt** (compound):
   - Fields: `status` (ASC), `createdAt` (DESC)
   - Purpose: List active workspaces sorted by creation date (newest first)

**Example Document**:

```json
{
  "id": "wks_abc123xyz",
  "name": "Summer Campaign 2025",
  "slug": "summer-campaign-2025",
  "status": "active",
  "deletedAt": null,
  "createdAt": 1735488000000,
  "updatedAt": 1735488000000
}
```

**Example Deleted Document**:

```json
{
  "id": "wks_def456uvw",
  "name": "Old Project",
  "slug": "old-project",
  "status": "deleted",
  "deletedAt": 1735574400000,
  "createdAt": 1735401600000,
  "updatedAt": 1735574400000
}
```

---

## TypeScript Types

### WorkspaceStatus

```typescript
/**
 * Workspace lifecycle state
 * - active: Workspace is accessible and visible in lists
 * - deleted: Workspace is soft-deleted (hidden from lists, slug unavailable for reuse)
 */
export type WorkspaceStatus = 'active' | 'deleted'
```

### Workspace

```typescript
/**
 * Workspace entity representing an organizational unit
 */
export interface Workspace {
  /** Unique workspace identifier (Firestore document ID) */
  id: string

  /** Human-readable workspace name (1-100 characters) */
  name: string

  /** URL-safe unique identifier (1-50 characters, lowercase, alphanumeric + hyphens) */
  slug: string

  /** Current lifecycle state (active | deleted) */
  status: WorkspaceStatus

  /** Unix timestamp (ms) when workspace was soft deleted (null if active) */
  deletedAt: number | null

  /** Unix timestamp (ms) when workspace was created */
  createdAt: number

  /** Unix timestamp (ms) of last modification */
  updatedAt: number
}
```

---

## Zod Schemas

### Constants

```typescript
// domains/workspace/constants/workspace.constants.ts

export const WORKSPACE_NAME = {
  min: 1,
  max: 100,
} as const

export const WORKSPACE_SLUG = {
  min: 1,
  max: 50,
  pattern: /^[a-z0-9][a-z0-9-]*[a-z0-9]$|^[a-z0-9]$/,
} as const
```

### Validation Schemas

```typescript
// domains/workspace/schemas/workspace.schemas.ts

import { z } from 'zod'
import { WORKSPACE_NAME, WORKSPACE_SLUG } from '../constants/workspace.constants'

/**
 * Workspace status enum schema
 */
export const workspaceStatusSchema = z.enum(['active', 'deleted'])

/**
 * Slug validation schema
 */
export const slugSchema = z
  .string()
  .min(WORKSPACE_SLUG.min, 'Slug is required')
  .max(WORKSPACE_SLUG.max, `Slug must be ${WORKSPACE_SLUG.max} characters or less`)
  .regex(
    WORKSPACE_SLUG.pattern,
    'Slug must contain only lowercase letters, numbers, and hyphens (no leading/trailing hyphens)'
  )

/**
 * Complete workspace entity schema
 */
export const workspaceSchema = z
  .object({
    id: z.string(),
    name: z
      .string()
      .min(WORKSPACE_NAME.min, 'Name is required')
      .max(WORKSPACE_NAME.max, `Name must be ${WORKSPACE_NAME.max} characters or less`),
    slug: slugSchema,
    status: workspaceStatusSchema,
    deletedAt: z.number().nullable(),
    createdAt: z.number(),
    updatedAt: z.number(),
  })
  .refine((data) => data.status === 'active' || data.deletedAt !== null, {
    message: 'deletedAt must be set when workspace is deleted',
    path: ['deletedAt'],
  })

/**
 * Input schema for creating a new workspace
 */
export const createWorkspaceSchema = z.object({
  name: z
    .string()
    .min(WORKSPACE_NAME.min, 'Name is required')
    .max(WORKSPACE_NAME.max, `Name must be ${WORKSPACE_NAME.max} characters or less`),
  slug: slugSchema.optional(), // Optional - auto-generated from name if not provided
})

/**
 * Input schema for soft deleting a workspace
 */
export const deleteWorkspaceSchema = z.object({
  id: z.string().min(1, 'Workspace ID is required'),
})

/**
 * Type inference from schemas
 */
export type WorkspaceSchema = z.infer<typeof workspaceSchema>
export type CreateWorkspaceInput = z.infer<typeof createWorkspaceSchema>
export type DeleteWorkspaceInput = z.infer<typeof deleteWorkspaceSchema>
```

---

## Firestore Security Rules

```javascript
// firebase/firestore.rules

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check admin claim
    function isAdmin() {
      return request.auth != null && request.auth.token.admin == true;
    }

    // Helper function to validate workspace data on create
    function isValidWorkspaceCreate() {
      let data = request.resource.data;
      return data.status == 'active' &&
             data.deletedAt == null &&
             data.createdAt is number &&
             data.updatedAt is number &&
             data.name is string &&
             data.slug is string &&
             data.id is string;
    }

    // Helper function to validate workspace update (soft delete)
    function isValidWorkspaceUpdate() {
      let data = request.resource.data;
      let oldData = resource.data;

      // Only allow status and deletedAt changes (soft delete)
      return data.diff(oldData).affectedKeys().hasOnly(['status', 'deletedAt', 'updatedAt']) &&
             data.status == 'deleted' &&
             data.deletedAt is number &&
             data.updatedAt is number;
    }

    // Workspace collection rules
    match /workspaces/{workspaceId} {
      // Allow admins to read any workspace (including deleted for slug uniqueness checks)
      allow read: if isAdmin();

      // Allow admins to create workspaces (with validation)
      allow create: if isAdmin() && isValidWorkspaceCreate();

      // Allow admins to update workspaces (soft delete only)
      allow update: if isAdmin() && isValidWorkspaceUpdate();

      // Deny hard deletes
      allow delete: if false;
    }
  }
}
```

**Rationale**:
- **Read access**: Admins can read all workspaces (including deleted) to check slug uniqueness
- **Create validation**: Enforce status='active', deletedAt=null, and required fields
- **Update validation**: Only allow soft delete (status → 'deleted', set deletedAt timestamp)
- **Hard delete**: Denied - only soft deletes allowed
- **Security**: Admin claim validation + data validation at Firebase level (cannot be bypassed)
- **Client-first**: Allows client SDK writes with server-side validation via rules

---

## Firestore Indexes

```json
{
  "indexes": [
    {
      "collectionGroup": "workspaces",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "slug", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" }
      ]
    },
    {
      "collectionGroup": "workspaces",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    }
  ],
  "fieldOverrides": []
}
```

**Index 1: Slug + Status**
- **Purpose**: Resolve workspace by slug (only active workspaces)
- **Query**: `where('slug', '==', slugParam).where('status', '==', 'active')`
- **Performance**: O(1) lookup

**Index 2: Status + CreatedAt**
- **Purpose**: List active workspaces sorted by creation date (newest first)
- **Query**: `where('status', '==', 'active').orderBy('createdAt', 'desc')`
- **Performance**: O(log N) for index lookup, O(M) for M active workspaces

---

## State Transition Details

### CREATE (active)

**Trigger**: Admin submits workspace creation form

**Preconditions**:
- User has admin claim (`admin: true`)
- Workspace name is valid (1-100 characters)
- Slug is unique (case-insensitive) across ALL workspaces (active + deleted)

**Operation** (client-side with Firestore client SDK):
1. Validate input with `createWorkspaceSchema` (Zod validation)
2. Generate slug from name if not provided (using `generateSlug()` utility)
3. Run Firestore **client SDK** transaction (`runTransaction`):
   - Query `workspaces` collection for `slug == inputSlug.toLowerCase()`
   - If exists (any status), abort with "Slug already exists" error
   - If unique, create document with:
     - `status = "active"`
     - `deletedAt = null`
     - `createdAt = Date.now()`
     - `updatedAt = Date.now()`
4. Firestore rules validate the write (admin-only, valid data structure)

**Postconditions**:
- Workspace exists with status "active"
- Workspace appears in admin workspace list (via real-time `onSnapshot`)
- Workspace is accessible via `/workspace/[slug]` URL

### SOFT DELETE (active → deleted)

**Trigger**: Admin confirms deletion from workspace list or workspace page

**Preconditions**:
- User has admin claim (`admin: true`)
- Workspace exists with status "active"

**Operation** (client-side with Firestore client SDK):
1. Validate input with `deleteWorkspaceSchema` (Zod validation)
2. Update Firestore document using `updateDoc`:
   - `status = "deleted"`
   - `deletedAt = Date.now()`
   - `updatedAt = Date.now()`
3. Firestore rules validate the update (admin-only, soft delete only)

**Postconditions**:
- Workspace status is "deleted"
- Workspace disappears from admin workspace list (via real-time `onSnapshot` filter)
- Workspace is inaccessible via `/workspace/[slug]` (query filters by status='active')
- Slug is permanently unavailable for reuse (transaction checks all workspaces)

**Note**: No restoration operation exists (terminal state). If workspace needs to be "restored", admin must create a new workspace with a different slug.

---

## Query Patterns

### List Active Workspaces

```typescript
const q = query(
  collection(db, 'workspaces'),
  where('status', '==', 'active'),
  orderBy('createdAt', 'desc')
)

const snapshot = await getDocs(q)
const workspaces = snapshot.docs.map(doc => doc.data() as Workspace)
```

### Get Workspace by Slug

```typescript
const q = query(
  collection(db, 'workspaces'),
  where('slug', '==', slugParam.toLowerCase()),
  where('status', '==', 'active'),
  limit(1)
)

const snapshot = await getDocs(q)
if (snapshot.empty) {
  throw new Error('Workspace not found')
}

const workspace = snapshot.docs[0].data() as Workspace
```

### Check Slug Uniqueness (Client SDK Transaction)

```typescript
import { runTransaction, collection, query, where, limit, getDocs } from 'firebase/firestore'
import { db } from '@/integrations/firebase/client'

// Inside Firestore client SDK transaction
await runTransaction(db, async (transaction) => {
  const workspacesRef = collection(db, 'workspaces')
  const q = query(workspacesRef, where('slug', '==', slug.toLowerCase()), limit(1))
  const existingSnapshot = await getDocs(q)

  if (!existingSnapshot.empty) {
    throw new Error('Slug already exists')
  }

  // Proceed with create if unique
  // ...
})
```

---

## Migration Plan

**Current State**: No `workspaces` collection exists in Firestore (new feature)

**Migration Steps**:
1. Deploy Firestore security rules (restrict access to admins)
2. Deploy Firestore indexes (slug+status, status+createdAt)
3. No data migration needed (starting from empty collection)
4. Remove mock workspace data from `navigation/constants/mockWorkspaces.ts` after implementation

**Rollback Plan**:
- If feature needs to be rolled back, delete all documents in `workspaces` collection
- Remove Firestore rules and indexes for `workspaces`
- Restore mock workspace data in navigation domain

---

## Testing Strategy

### Unit Tests

1. **Zod Schema Validation**:
   - Valid workspace passes `workspaceSchema`
   - Invalid slug (uppercase, leading hyphen) rejected
   - Invalid name (empty, > 100 chars) rejected
   - Status-deletedAt consistency enforced

2. **Slug Generation**:
   - `generateSlug("Acme Corp")` returns `"acme-corp"`
   - `generateSlug("Hello  World!!")` returns `"hello-world"`
   - Edge case: `generateSlug("a")` returns `"a"`

3. **Slug Validation**:
   - `isValidSlug("acme-corp")` returns `true`
   - `isValidSlug("Acme")` returns `false` (uppercase)
   - `isValidSlug("-acme")` returns `false` (leading hyphen)

### Integration Tests

1. **Workspace Creation Flow**:
   - Create workspace with valid name → success
   - Create workspace with duplicate slug → error
   - Create deleted workspace's slug → error (slug reuse prevented)

2. **Soft Delete Flow**:
   - Delete active workspace → status changes to "deleted"
   - Deleted workspace disappears from list query
   - Deleted workspace slug lookup returns "not found"

3. **Real-Time Updates**:
   - Create workspace → list auto-updates (onSnapshot)
   - Delete workspace → list auto-updates (onSnapshot)

### Manual Testing

1. **Mobile UX**: Test workspace list and creation form on iPhone/Android
2. **Concurrent Creation**: Open multiple tabs, create workspaces simultaneously (verify no duplicate slugs)
3. **Admin Guard**: Access `/admin/workspaces` as non-admin → redirected to login

---

## Performance Characteristics

| Operation | Latency Target | Scalability |
|-----------|----------------|-------------|
| List active workspaces | < 500ms | O(M) for M active workspaces |
| Get workspace by slug | < 200ms | O(1) indexed lookup |
| Create workspace | < 1000ms | O(1) transaction + write |
| Soft delete workspace | < 500ms | O(1) document update |
| Real-time update propagation | < 1000ms | Firestore WebSocket latency |

**Note**: Performance assumes < 500 active workspaces. If count exceeds 500, implement pagination with `startAfter` cursor.
