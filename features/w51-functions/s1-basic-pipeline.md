# Original PLan

- see ./plan.md

### Stage 1: Basic Pipeline - No Manipulation (Days 2-3)

**Goal**: End-to-end flow for passthrough processing. When no manipulations are configured, output the original media (single image) or composed media (GIF/video from burst).

### Key Principle

> When there are no manipulations (overlay, bg removal, AI transform), the output should be:
>
> - **Single image**: Original image URL
> - **Burst/multi-frame**: Composed GIF or video from original frames

### Key Requirements

#### 1. Request Parameters & Configuration

**API Request Body**:
```typescript
{
  sessionId: string;
  outputFormat: 'image' | 'gif' | 'video';  // Determines output type
  aspectRatio: 'square' | 'story';           // Output dimensions
}
```

**Processing Flow**:
1. Fetch session from Firestore: `/sessions/{sessionId}`
2. Load `inputAssets[]` from session (URLs to images in Storage)
3. Use `outputFormat` and `aspectRatio` from request to determine processing

**PipelineConfig** (simplified for Stage 1):
```typescript
interface PipelineConfig {
  outputFormat: 'image' | 'gif' | 'video';
  aspectRatio: 'square' | 'story';

  // Derived from aspectRatio:
  outputWidth: number;   // 1080 for both
  outputHeight: number;  // 1080 for square, 1920 for story

  // Defaults for GIF/video:
  frameDuration: 0.5;    // seconds per frame for GIF
  fps: 5;                // frames per second for video
}
```

**Storage Paths**:
- **Root bucket**: `gs://clementine-7568d.firebasestorage.app/`
- **Input assets**: `/projects/{projectId}/inputs/` (already uploaded)
- **Output results**: `/projects/{projectId}/results/` (generated by pipeline)
- **File naming**: `{sessionId}-output.{ext}` for primary, `{sessionId}-thumb.jpg` for thumbnail

**Note**: `inputAssets[]` array has no guaranteed order - process all frames in array order

#### 2. Single Image Processing

**When**: `inputAssets.length === 1` OR `outputFormat === 'image'`

**Requirements**:
- Download original image from input path
- Process with FFmpeg to ensure correct dimensions based on `aspectRatio`:
  - Square: 1080x1080px (crop/scale to fit)
  - Story: 1080x1920px (crop/scale to fit)
- Upload processed image to results bucket: `/projects/{projectId}/results/{sessionId}-output.jpg`
- Generate thumbnail (max 300px width, maintain aspect ratio): `/projects/{projectId}/results/{sessionId}-thumb.jpg`
- Extract metadata (dimensions, file size)

**FFmpeg Strategy**:
- Scale and crop to target dimensions
- Maintain quality while optimizing file size

**Output Schema**:
```typescript
{
  primaryUrl: string;        // Processed image in results bucket
  thumbnailUrl: string;      // Thumbnail for preview
  format: 'image';
  dimensions: { width: number; height: number };
  sizeBytes: number;
  completedAt: Date;
  processingTimeMs: number;
}
```

#### 3. GIF Composition

**When**: `inputAssets.length > 1` AND `outputFormat === 'gif'`

**Requirements**:
- Download all input frames to temp directory
- Process frames in array order (no sorting - use as-is)
- Apply all frames in sequence (simple loop, no pattern manipulation in Stage 1)
- Generate GIF using FFmpeg:
  - Frame duration: 0.5s per frame (hardcoded default)
  - Output dimensions based on `aspectRatio`:
    - Square: 1080x1080px
    - Story: 1080x1920px
  - Infinite loop (`-loop 0`)
  - Palette generation for optimal colors
- Upload composed GIF to: `/projects/{projectId}/results/{sessionId}-output.gif`
- Generate thumbnail from first frame: `/projects/{projectId}/results/{sessionId}-thumb.jpg`
- Clean up temp files

**FFmpeg Strategy**:
- Concat filter to sequence frames
- Scale and crop to target dimensions (center crop if needed)
- Palette optimization for file size reduction

**Output Schema**:
```typescript
{
  primaryUrl: string;        // Composed GIF in results bucket
  thumbnailUrl: string;      // Thumbnail from first frame
  format: 'gif';
  dimensions: { width: number; height: number };
  sizeBytes: number;
  completedAt: Date;
  processingTimeMs: number;
}
```

#### 4. Video Composition

**When**: `inputAssets.length > 1` AND `outputFormat === 'video'`

**Requirements**:
- Download all input frames to temp directory
- Process frames in array order (no sorting - use as-is)
- Name frames with zero-padded sequence (`frame-0000.jpg`, `frame-0001.jpg`, etc.)
- Generate MP4 using FFmpeg:
  - FPS: 5fps (hardcoded default)
  - Output dimensions based on `aspectRatio`:
    - Square: 1080x1080px
    - Story: 1080x1920px
  - H.264 codec with `yuv420p` pixel format (max compatibility)
  - Fast start for web playback (`-movflags +faststart`)
- Upload composed video to: `/projects/{projectId}/results/{sessionId}-output.mp4`
- Generate thumbnail from first frame: `/projects/{projectId}/results/{sessionId}-thumb.jpg`
- Clean up temp files

**FFmpeg Strategy**:
- Input pattern: `frame-%04d.jpg`
- Scale and crop to target dimensions (center crop if needed)
- Optimized for web streaming

**Output Schema**:
```typescript
{
  primaryUrl: string;        // Composed MP4 in results bucket
  thumbnailUrl: string;      // Thumbnail from first frame
  format: 'video';
  dimensions: { width: number; height: number };
  sizeBytes: number;
  completedAt: Date;
  processingTimeMs: number;
}
```

### Deliverables

**1. API Endpoint**

```tsx
// functions/src/functions/processMedia.ts
import { onRequest, HttpsError } from "firebase-functions/v2/https";
import { Session } from "@clementine/shared";

export const processMedia = onRequest(
  {
    minInstances: 1, // Keep warm for user-facing requests
    timeoutSeconds: 30,
    cors: true,
  },
  async (req, res) => {
    if (req.method !== "POST") {
      res.status(405).send("Method not allowed");
      return;
    }

    const { sessionId, outputFormat, aspectRatio } = req.body;

    // Validate request
    if (!sessionId || !outputFormat || !aspectRatio) {
      throw new HttpsError("invalid-argument", "Missing required parameters");
    }

    if (!["image", "gif", "video"].includes(outputFormat)) {
      throw new HttpsError("invalid-argument", "Invalid outputFormat");
    }

    if (!["square", "story"].includes(aspectRatio)) {
      throw new HttpsError("invalid-argument", "Invalid aspectRatio");
    }

    // 1. Validate session exists and not already processing
    const session = await getSession(sessionId);
    if (!session) {
      throw new HttpsError("not-found", "Session not found");
    }

    if (session.processing?.state === "running") {
      res.json({ sessionId, status: "already_processing" });
      return;
    }

    // 2. Mark as pending
    await updateSession(sessionId, {
      processing: {
        state: "pending",
        currentStep: "queued",
        startedAt: new Date(),
        updatedAt: new Date(),
        attemptNumber: 1,
        taskId: `task-${sessionId}-${Date.now()}`,
      },
    });

    // 3. Queue Cloud Task with config
    await queueProcessingTask(sessionId, { outputFormat, aspectRatio });

    res.json({ sessionId, status: "queued" });
  }
);
```

**2. Task Processor**

```tsx
// functions/src/functions/processMediaJob.ts
import { onTaskDispatched } from "firebase-functions/v2/tasks";
import { logger } from "firebase-functions";

export const processMediaJob = onTaskDispatched(
  {
    retryConfig: {
      maxAttempts: 3,
      minBackoffSeconds: 30,
    },
    rateLimits: {
      maxConcurrentDispatches: 10,
    },
    timeoutSeconds: 1800, // 30 min for heavy processing
    minInstances: 0, // Cold starts OK for background jobs
  },
  async (req) => {
    const { sessionId, outputFormat, aspectRatio } = req.data;

    logger.info("Processing started", { sessionId, outputFormat, aspectRatio });

    try {
      // Update to running
      await updateProcessingState(sessionId, "running", "loading");

      // Load session
      const session = await getSession(sessionId);

      // Build config from request params
      const config: PipelineConfig = {
        outputFormat,
        aspectRatio,
        outputWidth: 1080,
        outputHeight: aspectRatio === "square" ? 1080 : 1920,
        frameDuration: 0.5,
        fps: 5,
      };

      // Determine output type based on request and inputs
      const outputType = determineOutputType(session.inputAssets, config);

      // Process based on type
      let output: SessionOutputs;

      if (outputType === "single-image") {
        output = await processSingleImage(session, config);
      } else if (outputType === "compose-gif") {
        output = await composeGif(session, config);
      } else if (outputType === "compose-video") {
        output = await composeVideo(session, config);
      }

      // Save outputs and clear processing state
      await completeProcessing(sessionId, output);

      logger.info("Processing completed", { sessionId, format: output.format });
    } catch (error) {
      await handleProcessingError(sessionId, error, "unknown");
      throw error; // Re-throw for Cloud Tasks retry
    }
  }
);
```

**3. Output Type Determination**

```tsx
// functions/src/services/pipelineService.ts
type OutputType = "single-image" | "compose-gif" | "compose-video";

function determineOutputType(
  inputAssets: InputAsset[],
  config: PipelineConfig
): OutputType {
  // If outputFormat is 'image', always process as single image
  if (config.outputFormat === "image") {
    return "single-image";
  }

  // Single input asset - process as single image
  if (inputAssets.length === 1) {
    return "single-image";
  }

  // Multiple assets - compose based on outputFormat
  if (config.outputFormat === "video") {
    return "compose-video";
  }

  return "compose-gif"; // Default for multi-frame
}
```

**4. Single Image Processing**

```tsx
// functions/src/services/mediaService.ts
async function processSingleImage(
  session: Session,
  config: PipelineConfig
): Promise<SessionOutputs> {
  const input = session.inputAssets[0];
  const tempDir = `/tmp/${session.id}`;
  await fs.mkdir(tempDir, { recursive: true });

  // Download input
  const inputPath = `${tempDir}/input.jpg`;
  await downloadFile(input.url, inputPath);

  // Process with FFmpeg to target dimensions
  const outputPath = `${tempDir}/output.jpg`;
  await processImage(inputPath, outputPath, {
    width: config.outputWidth,
    height: config.outputHeight,
  });

  // Upload to results bucket
  const primaryUrl = await uploadToStorage(
    outputPath,
    `projects/${session.projectId}/results/${session.id}-output.jpg`
  );

  // Generate thumbnail
  const thumbnailPath = `${tempDir}/thumb.jpg`;
  await generateThumbnail(outputPath, thumbnailPath, { maxWidth: 300 });
  const thumbnailUrl = await uploadToStorage(
    thumbnailPath,
    `projects/${session.projectId}/results/${session.id}-thumb.jpg`
  );

  const stats = await fs.stat(outputPath);

  await fs.rm(tempDir, { recursive: true });

  return {
    primaryUrl,
    thumbnailUrl,
    format: "image",
    dimensions: { width: config.outputWidth, height: config.outputHeight },
    sizeBytes: stats.size,
    completedAt: new Date(),
    processingTimeMs: Date.now() - session.processing!.startedAt.getTime(),
  };
}
```

**5. GIF Composition**

```tsx
// functions/src/services/gifService.ts
import ffmpeg from "fluent-ffmpeg";
import ffmpegPath from "ffmpeg-static";

ffmpeg.setFfmpegPath(ffmpegPath);

async function composeGif(
  session: Session,
  config: PipelineConfig
): Promise<SessionOutputs> {
  const frames = session.inputAssets; // Use as-is, no sorting
  const frameDuration = config.frameDuration; // 0.5s

  // Download frames to temp
  const tempDir = `/tmp/${session.id}`;
  await fs.mkdir(tempDir, { recursive: true });

  const localFrames = await Promise.all(
    frames.map(async (frame, i) => {
      const localPath = `${tempDir}/frame-${i}.jpg`;
      await downloadFile(frame.url, localPath);
      return localPath;
    })
  );

  // Create GIF
  const outputPath = `${tempDir}/output.gif`;
  await createGifFromFrames(localFrames, outputPath, {
    frameDuration,
    width: config.outputWidth,
    height: config.outputHeight,
    loop: 0, // infinite loop
  });

  // Upload to results bucket
  const primaryUrl = await uploadToStorage(
    outputPath,
    `projects/${session.projectId}/results/${session.id}-output.gif`
  );

  // Generate thumbnail
  const thumbnailPath = `${tempDir}/thumb.jpg`;
  await generateThumbnail(localFrames[0], thumbnailPath, { maxWidth: 300 });
  const thumbnailUrl = await uploadToStorage(
    thumbnailPath,
    `projects/${session.projectId}/results/${session.id}-thumb.jpg`
  );

  const stats = await fs.stat(outputPath);

  await fs.rm(tempDir, { recursive: true });

  return {
    primaryUrl,
    thumbnailUrl,
    format: "gif",
    dimensions: { width: config.outputWidth, height: config.outputHeight },
    sizeBytes: stats.size,
    completedAt: new Date(),
    processingTimeMs: Date.now() - session.processing!.startedAt.getTime(),
  };
}

async function createGifFromFrames(
  frames: string[],
  outputPath: string,
  options: GifOptions
): Promise<void> {
  return new Promise((resolve, reject) => {
    const cmd = ffmpeg();

    frames.forEach((frame) => {
      cmd
        .input(frame)
        .inputOptions(["-loop", "1", "-t", String(options.frameDuration)]);
    });

    cmd
      .complexFilter([
        `concat=n=${frames.length}:v=1:a=0[v]`,
        `[v]scale=${options.width}:${options.height}:force_original_aspect_ratio=decrease,pad=${options.width}:${options.height}:(ow-iw)/2:(oh-ih)/2[scaled]`,
        `[scaled]split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse[out]`,
      ])
      .outputOptions(["-loop", String(options.loop)])
      .output(outputPath)
      .on("end", resolve)
      .on("error", reject)
      .run();
  });
}
```

**6. Video Composition**

```tsx
// functions/src/services/videoService.ts
async function composeVideo(
  session: Session,
  config: PipelineConfig
): Promise<SessionOutputs> {
  const frames = session.inputAssets; // Use as-is, no sorting
  const fps = config.fps; // 5fps

  const tempDir = `/tmp/${session.id}`;
  await fs.mkdir(tempDir, { recursive: true });

  // Download frames
  const localFrames = await Promise.all(
    frames.map(async (frame, i) => {
      const localPath = `${tempDir}/frame-${String(i).padStart(4, "0")}.jpg`;
      await downloadFile(frame.url, localPath);
      return localPath;
    })
  );

  // Create video
  const outputPath = `${tempDir}/output.mp4`;
  await createVideoFromFrames(tempDir, outputPath, {
    fps,
    width: config.outputWidth,
    height: config.outputHeight,
  });

  // Upload to results bucket
  const primaryUrl = await uploadToStorage(
    outputPath,
    `projects/${session.projectId}/results/${session.id}-output.mp4`
  );

  // Generate thumbnail
  const thumbnailPath = `${tempDir}/thumb.jpg`;
  await generateThumbnail(localFrames[0], thumbnailPath, { maxWidth: 300 });
  const thumbnailUrl = await uploadToStorage(
    thumbnailPath,
    `projects/${session.projectId}/results/${session.id}-thumb.jpg`
  );

  const stats = await fs.stat(outputPath);

  await fs.rm(tempDir, { recursive: true });

  return {
    primaryUrl,
    thumbnailUrl,
    format: "video",
    dimensions: { width: config.outputWidth, height: config.outputHeight },
    sizeBytes: stats.size,
    completedAt: new Date(),
    processingTimeMs: Date.now() - session.processing!.startedAt.getTime(),
  };
}

async function createVideoFromFrames(
  inputDir: string,
  outputPath: string,
  options: VideoOptions
): Promise<void> {
  return new Promise((resolve, reject) => {
    ffmpeg()
      .input(`${inputDir}/frame-%04d.jpg`)
      .inputFPS(options.fps)
      .outputOptions([
        "-c:v libx264",
        "-pix_fmt yuv420p",
        "-movflags +faststart",
        `-vf scale=${options.width}:${options.height}:force_original_aspect_ratio=decrease,pad=${options.width}:${options.height}:(ow-iw)/2:(oh-ih)/2`,
      ])
      .output(outputPath)
      .on("end", resolve)
      .on("error", reject)
      .run();
  });
}
```

**7. Client Real-time Subscription**

```tsx
// web/src/hooks/useSessionProcessing.ts
import { doc, onSnapshot } from "firebase/firestore";
import { Session } from "@clementine/shared";

export function useSessionProcessing(sessionId: string) {
  const [session, setSession] = useState<Session | null>(null);
  const [status, setStatus] = useState<
    "idle" | "processing" | "complete" | "error"
  >("idle");

  useEffect(() => {
    if (!sessionId) return;

    const unsubscribe = onSnapshot(doc(db, "sessions", sessionId), (doc) => {
      const data = doc.data() as Session;
      setSession(data);

      if (data.outputs) {
        setStatus("complete");
      } else if (data.processing?.state === "failed") {
        setStatus("error");
      } else if (data.processing) {
        setStatus("processing");
      }
    });

    return () => unsubscribe();
  }, [sessionId]);

  return { session, status };
}
```

**8. Helper Functions**

```tsx
// functions/src/services/processingService.ts
async function updateProcessingState(
  sessionId: string,
  state: ProcessingState["state"],
  step: string
): Promise<void> {
  await db.doc(`sessions/${sessionId}`).update({
    "processing.state": state,
    "processing.currentStep": step,
    "processing.updatedAt": FieldValue.serverTimestamp(),
  });

  logger.info("Processing state updated", {
    sessionId,
    state,
    step,
    labels: { component: "media-processor" },
  });
}

async function completeProcessing(
  sessionId: string,
  outputs: SessionOutputs
): Promise<void> {
  await db.doc(`sessions/${sessionId}`).update({
    outputs,
    processing: FieldValue.delete(), // Clear temporary state
  });

  logger.info("Processing completed", {
    sessionId,
    format: outputs.format,
    sizeBytes: outputs.sizeBytes,
    processingTimeMs: outputs.processingTimeMs,
    labels: { component: "media-processor", status: "success" },
  });
}
```

### Testing Checkpoint

- [ ] Single image session → outputs original image URL
- [ ] 4-image burst → outputs composed GIF
- [ ] Burst with `outputFormat: 'mp4'` → outputs MP4
- [ ] Client receives real-time updates (pending → running → complete)
- [ ] Logs show sessionId, step, and timing

---
